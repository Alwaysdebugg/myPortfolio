"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[348],{6348:n=>{n.exports=JSON.parse('[{"id":"deep-copy-vs-shallow-copy","title":"深拷贝 VS 浅拷贝","slug":"deep-copy-vs-shallow-copy","excerpt":"从代码分割、懒加载到Web Vitals优化，全面提升前端应用性能的最佳实践和工具推荐。","content":"\\n## 浅拷贝（Shallow Copy）｜  深拷贝（Deep Copy）\\n\\n想要理解深浅拷贝之间的区别，需要了解一下几个概念：第一层属性；嵌套对象；引用类型；\\n\\n第一层属性(Top-Level properties)：\\n\\t对象直接包含的属性，不包括嵌套在里面的object或者array；\\n\\t\\n```\\nconst obj = {\\n    name: \\"Alice\\",   // 第一层属性（基本类型）\\n    age: 25,         // 第一层属性（基本类型）\\n    address: {       // 第一层属性，但它的值是一个嵌套对象\\n        city: \\"New York\\"\\n    }\\n};\\n\\n```\\n\\n嵌套对象(Nested Object)：\\n\\t 是指作为另一个对象的属性值的对象，简单来说就是，被套在另一个object中的object；\\n\\t \\n```\\nconst obj = {\\n    name: \\"Alice\\",   \\n    age: 25,         \\n    address: {       // Nested Object\\n        city: \\"New York\\"\\n    }\\n};\\n```\\n这里可以提一下关于如何访问Nested Object的方式，两种：\\n- const city = object.address.city;\\n- const city = object [\\"address\\"]  [\\"city\\"]\\n\\n引用类型(Reference Type)\\n\\t在JS中的值分为两类：\\n\\t\\t- 基本类型（Primitive Type）：直接存储值\\n\\t\\t\\t- `Number`、`String`、`Boolean`、`null`、`undefined`、`Symbol`、`BigInt`\\n\\t\\t\\t- **赋值时会复制值本身**（即使赋值后改变，新变量和原变量不会互相影响）\\n\\t\\t-  引用类型（Reference Type）：存储的是地址\\n\\t\\t\\t- `Object`、`Array`、`Function`\\n\\t\\t\\t- 赋值时复制的是地址（reference）\\n\\t\\t\\t- 多个变量会共享同一个对象的引用，修改其中一个会影响另一个\\n\\n```\\nlet a = { value: 10 };  // a 存储的是 { value: 10 } 的地址\\nlet b = a;  // b 复制了 a 的地址，而不是对象本身\\n\\nb.value = 20;  // 修改 b.value 也会影响 a.value\\n\\nconsole.log(a.value);  // 20\\nconsole.log(b.value);  // 20\\n\\n```\\n\\n### 因此得出结论：\\n\\n何为浅拷贝？ ——  赋值的过程中只copy了第一层属性，但是嵌套在其中的object是引用；因此在这种情况下，不推荐对赋值对象进行操作。\\n\\n何为深拷贝？ —— 递归复制所有层级，嵌套对象也是全新的副本，不共享引用。\\n\\n### 在日常开发中，有哪些深拷贝的方式？\\n\\n#### JSON.parse | JSON.stringify\\n\\n 举例：const obj2 = JSON.parse( JSON.stringify ( obj1 ) )\\n \\n这是一个将object序列化和反序列化的过程，首先stringify方法会递归的转化对象，将其转换为字符串；parse方法可以将字符串转换成object格式，从而实现不共享原对象的引用。\\n\\n该方法不能处理的类型：undefined, Function, Symbol, RegExp, Date, Circular References.\\n\\n#### JS内置深拷贝方法\\n\\n举例： **const deepCopy = structuredClone(obj1)**\\n\\n浏览器原生API, 可处理循环引用。\\n\\n\\n","author":"Jacky Feng","publishedAt":"2025-03-01","tags":["JS","深拷贝","浅拷贝"],"readingTime":8,"isPublished":true},{"id":"react-18-new-features","title":"React 18 新特性深度解析","slug":"react-18-new-features","excerpt":"深入探讨 React 18 带来的并发特性、自动批处理、以及新的 Hooks，了解如何在项目中应用这些新特性。","content":"\\r\\n# React 18 新特性深度解析\\r\\n\\r\\nReact 18 是一个重要的版本更新，引入了许多令人兴奋的新特性。\\r\\n\\r\\n## 并发特性 (Concurrent Features)\\r\\n\\r\\nReact 18 的最大亮点是**并发渲染**，这使得 React 应用能够更好地响应用户交互。\\r\\n\\r\\n### Suspense 改进\\r\\n\\r\\n```jsx\\r\\nimport { Suspense } from \'react\'\\r\\n\\r\\nfunction App() {\\r\\n  return (\\r\\n    <Suspense fallback={<Loading />}>\\r\\n      <ProfilePage />\\r\\n    </Suspense>\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n### 新的 Hooks\\r\\n\\r\\nReact 18 引入了几个新的 Hooks：\\r\\n\\r\\n- **useId**: 生成唯一ID\\r\\n- **useTransition**: 标记非紧急更新\\r\\n- **useDeferredValue**: 延迟更新值\\r\\n\\r\\n## 自动批处理\\r\\n\\r\\nReact 18 现在会自动批处理所有更新，包括Promise、setTimeout 等异步操作中的更新。\\r\\n\\r\\n```jsx\\r\\n// React 18 会自动批处理这些更新\\r\\nsetTimeout(() => {\\r\\n  setCount(c => c + 1)\\r\\n  setFlag(f => !f)\\r\\n  // React 只会重新渲染一次\\r\\n}, 1000)\\r\\n```\\r\\n\\r\\n## useTransition Hook\\r\\n\\r\\n`useTransition` 允许你将状态更新标记为\\"转换\\"，这些更新将具有较低的优先级。\\r\\n\\r\\n```jsx\\r\\nimport { useTransition, useState } from \'react\'\\r\\n\\r\\nfunction App() {\\r\\n  const [isPending, startTransition] = useTransition()\\r\\n  const [count, setCount] = useState(0)\\r\\n  \\r\\n  function handleClick() {\\r\\n    startTransition(() => {\\r\\n      setCount(c => c + 1)\\r\\n    })\\r\\n  }\\r\\n  \\r\\n  return (\\r\\n    <div>\\r\\n      {isPending && <Spinner />}\\r\\n      <button onClick={handleClick}>{count}</button>\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n## 严格模式的变化\\r\\n\\r\\nReact 18 的严格模式现在会**双重渲染组件**，这有助于发现副作用问题。\\r\\n\\r\\n> 在开发模式下，React 会故意双重调用组件、初始化函数和状态更新函数。\\r\\n\\r\\n## 总结\\r\\n\\r\\nReact 18 为现代 React 应用开发带来了更强大的性能优化能力。这些新特性让我们能够构建更加流畅和响应式的用户界面。\\r\\n\\r\\n### 关键要点\\r\\n\\r\\n1. **并发特性**提升了应用的响应性\\r\\n2. **自动批处理**减少了不必要的重新渲染\\r\\n3. **新的 Hooks** 提供了更精细的控制能力\\r\\n4. **严格模式**帮助开发者发现潜在问题","author":"Jacky Feng","publishedAt":"2024-01-15","updatedAt":"2024-01-20","tags":["React","JavaScript","前端开发","Hooks"],"readingTime":8,"coverImage":"/images/react18-cover.jpg","isPublished":true},{"id":"typescript-advanced-types","title":"TypeScript 高级类型实战指南","slug":"typescript-advanced-types","excerpt":"掌握 TypeScript 的高级类型系统，包括条件类型、映射类型、模板字面量类型等，提升代码质量和开发效率。","content":"\\r\\n# TypeScript 高级类型实战指南\\r\\n\\r\\nTypeScript 的类型系统非常强大，本文将深入探讨一些高级类型特性。\\r\\n\\r\\n## 条件类型 (Conditional Types)\\r\\n\\r\\n条件类型允许我们根据条件选择类型：\\r\\n\\r\\n```typescript\\r\\ntype NonNullable<T> = T extends null | undefined ? never : T\\r\\n\\r\\n// 使用示例\\r\\ntype A = NonNullable<string | null> // string\\r\\ntype B = NonNullable<number | undefined> // number\\r\\n```\\r\\n\\r\\n### 分布式条件类型\\r\\n\\r\\n当条件类型作用于联合类型时，会分布到每个成员：\\r\\n\\r\\n```typescript\\r\\ntype ToArray<Type> = Type extends any ? Type[] : never\\r\\n\\r\\n// SuccessState | ErrorState[] | LoadingState[]\\r\\ntype StrArrOrNumArr = ToArray<string | number | boolean>\\r\\n```\\r\\n\\r\\n## 映射类型 (Mapped Types)\\r\\n\\r\\n映射类型可以基于已有类型创建新类型：\\r\\n\\r\\n```typescript\\r\\ntype Readonly<T> = {\\r\\n  readonly [P in keyof T]: T[P]\\r\\n}\\r\\n\\r\\ntype Optional<T> = {\\r\\n  [P in keyof T]?: T[P]\\r\\n}\\r\\n\\r\\n// 实际应用\\r\\ninterface User {\\r\\n  id: number\\r\\n  name: string\\r\\n  email: string\\r\\n}\\r\\n\\r\\ntype ReadonlyUser = Readonly<User>\\r\\ntype PartialUser = Optional<User>\\r\\n```\\r\\n\\r\\n### 键重映射\\r\\n\\r\\nTypeScript 4.1+ 支持键重映射：\\r\\n\\r\\n```typescript\\r\\ntype Getters<Type> = {\\r\\n  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\\r\\n}\\r\\n\\r\\ninterface Person {\\r\\n  name: string\\r\\n  age: number\\r\\n  location: string\\r\\n}\\r\\n\\r\\ntype PersonGetters = Getters<Person>\\r\\n// {\\r\\n//   getName: () => string\\r\\n//   getAge: () => number\\r\\n//   getLocation: () => string\\r\\n// }\\r\\n```\\r\\n\\r\\n## 模板字面量类型\\r\\n\\r\\nTypeScript 4.1+ 支持模板字面量类型：\\r\\n\\r\\n```typescript\\r\\ntype EmailLocaleIDs = \\"welcome_email\\" | \\"email_heading\\"\\r\\ntype FooterLocaleIDs = \\"footer_title\\" | \\"footer_sendoff\\"\\r\\n\\r\\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`\\r\\n// \\"welcome_email_id\\" | \\"email_heading_id\\" | \\"footer_title_id\\" | \\"footer_sendoff_id\\"\\r\\n```\\r\\n\\r\\n### 实际应用案例\\r\\n\\r\\n```typescript\\r\\n// API 路径类型安全\\r\\ntype Version = \\"v1\\" | \\"v2\\"\\r\\ntype Resource = \\"users\\" | \\"posts\\" | \\"comments\\"\\r\\ntype Endpoint = `/${Version}/${Resource}`\\r\\n\\r\\n// CSS 属性类型\\r\\ntype Size = \\"sm\\" | \\"md\\" | \\"lg\\"\\r\\ntype Color = \\"red\\" | \\"blue\\" | \\"green\\"\\r\\ntype ClassName = `${Size}-${Color}`\\r\\n```\\r\\n\\r\\n## 实用类型组合\\r\\n\\r\\n结合多种高级类型创建强大的工具类型：\\r\\n\\r\\n```typescript\\r\\n// 深度只读\\r\\ntype DeepReadonly<T> = {\\r\\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\\r\\n}\\r\\n\\r\\n// 选择性必需\\r\\ntype RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>\\r\\n\\r\\n// 类型安全的对象路径\\r\\ntype PathsToStringProps<T> = T extends string\\r\\n  ? []\\r\\n  : {\\r\\n      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>]\\r\\n    }[Extract<keyof T, string>]\\r\\n```\\r\\n\\r\\n## 最佳实践\\r\\n\\r\\n### 1. 类型守卫\\r\\n\\r\\n```typescript\\r\\nfunction isString(value: unknown): value is string {\\r\\n  return typeof value === \'string\'\\r\\n}\\r\\n\\r\\nfunction processValue(value: unknown) {\\r\\n  if (isString(value)) {\\r\\n    // TypeScript 知道这里 value 是 string\\r\\n    console.log(value.toUpperCase())\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### 2. 断言函数\\r\\n\\r\\n```typescript\\r\\nfunction assert(condition: any, msg?: string): asserts condition {\\r\\n  if (!condition) {\\r\\n    throw new Error(msg)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processUser(user: unknown) {\\r\\n  assert(typeof user === \'object\' && user !== null, \'User must be an object\')\\r\\n  assert(\'name\' in user, \'User must have a name\')\\r\\n  \\r\\n  // TypeScript 现在知道 user 有 name 属性\\r\\n  console.log((user as any).name)\\r\\n}\\r\\n```\\r\\n\\r\\n## 总结\\r\\n\\r\\n这些高级类型特性让我们能够构建更加类型安全的应用程序：\\r\\n\\r\\n- **条件类型**提供了动态类型选择能力\\r\\n- **映射类型**让类型转换变得优雅\\r\\n- **模板字面量类型**带来了字符串级别的类型安全\\r\\n- **合理组合**这些特性可以创建强大的工具类型\\r\\n\\r\\n掌握这些高级特性，能够大大提升 TypeScript 代码的表达力和安全性。","author":"Jacky Feng","publishedAt":"2024-01-10","tags":["TypeScript","类型系统","前端开发"],"readingTime":12,"isPublished":true},{"id":"frontend-performance-optimization","title":"现代前端性能优化实践","slug":"frontend-performance-optimization","excerpt":"从代码分割、懒加载到Web Vitals优化，全面提升前端应用性能的最佳实践和工具推荐。","content":"\\r\\n# 现代前端性能优化实践\\r\\n\\r\\n性能优化是前端开发中的重要课题，本文将介绍一些实用的优化策略。\\r\\n\\r\\n## Core Web Vitals\\r\\n\\r\\nGoogle 的 Core Web Vitals 包含三个重要指标：\\r\\n\\r\\n- **LCP (Largest Contentful Paint)**: 最大内容绘制 - 应 < 2.5s\\r\\n- **FID (First Input Delay)**: 首次输入延迟 - 应 < 100ms\\r\\n- **CLS (Cumulative Layout Shift)**: 累积布局偏移 - 应 < 0.1\\r\\n\\r\\n### 测量工具\\r\\n\\r\\n- **Lighthouse**: 综合性能分析\\r\\n- **PageSpeed Insights**: Google 官方工具\\r\\n- **Web Vitals Extension**: Chrome 扩展\\r\\n- **Real User Monitoring (RUM)**: 真实用户数据\\r\\n\\r\\n## 代码分割策略\\r\\n\\r\\n### 路由级别分割\\r\\n\\r\\n```javascript\\r\\nimport { lazy, Suspense } from \'react\'\\r\\n\\r\\nconst HomePage = lazy(() => import(\'./pages/Home\'))\\r\\nconst AboutPage = lazy(() => import(\'./pages/About\'))\\r\\n\\r\\nfunction App() {\\r\\n  return (\\r\\n    <Suspense fallback={<div>Loading...</div>}>\\r\\n      <Routes>\\r\\n        <Route path=\\"/\\" element={<HomePage />} />\\r\\n        <Route path=\\"/about\\" element={<AboutPage />} />\\r\\n      </Routes>\\r\\n    </Suspense>\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n### 组件级别分割\\r\\n\\r\\n对于大型组件，也可以进行分割：\\r\\n\\r\\n```javascript\\r\\nconst HeavyChart = lazy(() => import(\'./HeavyChart\'))\\r\\n\\r\\nfunction Dashboard() {\\r\\n  const [showChart, setShowChart] = useState(false)\\r\\n  \\r\\n  return (\\r\\n    <div>\\r\\n      <button onClick={() => setShowChart(true)}>\\r\\n        显示图表\\r\\n      </button>\\r\\n      {showChart && (\\r\\n        <Suspense fallback={<ChartSkeleton />}>\\r\\n          <HeavyChart />\\r\\n        </Suspense>\\r\\n      )}\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n### 第三方库分割\\r\\n\\r\\n```javascript\\r\\n// 动态导入第三方库\\r\\nconst loadChartLibrary = async () => {\\r\\n  const { Chart } = await import(\'chart.js\')\\r\\n  return Chart\\r\\n}\\r\\n\\r\\n// 或者创建独立的 chunk\\r\\nconst DatePicker = lazy(() => \\r\\n  import(/* webpackChunkName: \\"date-picker\\" */ \'./DatePicker\')\\r\\n)\\r\\n```\\r\\n\\r\\n## 图片优化\\r\\n\\r\\n### 现代图片格式\\r\\n\\r\\n```html\\r\\n<picture>\\r\\n  <source srcset=\\"image.avif\\" type=\\"image/avif\\">\\r\\n  <source srcset=\\"image.webp\\" type=\\"image/webp\\">\\r\\n  <img src=\\"image.jpg\\" alt=\\"description\\" loading=\\"lazy\\">\\r\\n</picture>\\r\\n```\\r\\n\\r\\n### 响应式图片\\r\\n\\r\\n```html\\r\\n<img \\r\\n  srcset=\\"\\r\\n    small.jpg 480w,\\r\\n    medium.jpg 768w,\\r\\n    large.jpg 1200w\\r\\n  \\"\\r\\n  sizes=\\"\\r\\n    (max-width: 480px) 100vw,\\r\\n    (max-width: 768px) 50vw,\\r\\n    33vw\\r\\n  \\"\\r\\n  src=\\"medium.jpg\\"\\r\\n  alt=\\"Responsive image\\"\\r\\n  loading=\\"lazy\\"\\r\\n>\\r\\n```\\r\\n\\r\\n### Next.js Image 组件\\r\\n\\r\\n```jsx\\r\\nimport Image from \'next/image\'\\r\\n\\r\\nfunction OptimizedImage() {\\r\\n  return (\\r\\n    <Image\\r\\n      src=\\"/hero-image.jpg\\"\\r\\n      alt=\\"Hero\\"\\r\\n      width={800}\\r\\n      height={600}\\r\\n      priority // 对于 LCP 图片\\r\\n      placeholder=\\"blur\\"\\r\\n      blurDataURL=\\"data:image/jpeg;base64,...\\"\\r\\n    />\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n## 资源预加载策略\\r\\n\\r\\n### 关键资源预加载\\r\\n\\r\\n```html\\r\\n\x3c!-- 预加载关键字体 --\x3e\\r\\n<link rel=\\"preload\\" href=\\"/fonts/main.woff2\\" as=\\"font\\" type=\\"font/woff2\\" crossorigin>\\r\\n\\r\\n\x3c!-- 预加载关键 CSS --\x3e\\r\\n<link rel=\\"preload\\" href=\\"/styles/critical.css\\" as=\\"style\\">\\r\\n\\r\\n\x3c!-- 预连接到第三方域名 --\x3e\\r\\n<link rel=\\"preconnect\\" href=\\"https://fonts.googleapis.com\\">\\r\\n<link rel=\\"dns-prefetch\\" href=\\"//example.com\\">\\r\\n```\\r\\n\\r\\n### 路由预加载\\r\\n\\r\\n```javascript\\r\\n// React Router 路由预加载\\r\\nimport { Link } from \'react-router-dom\'\\r\\n\\r\\nfunction Navigation() {\\r\\n  return (\\r\\n    <Link \\r\\n      to=\\"/dashboard\\"\\r\\n      onMouseEnter={() => {\\r\\n        // 鼠标悬停时预加载\\r\\n        import(\'./pages/Dashboard\')\\r\\n      }}\\r\\n    >\\r\\n      Dashboard\\r\\n    </Link>\\r\\n  )\\r\\n}\\r\\n```\\r\\n\\r\\n## 缓存策略\\r\\n\\r\\n### 浏览器缓存\\r\\n\\r\\n```javascript\\r\\n// Service Worker 缓存策略\\r\\nself.addEventListener(\'fetch\', (event) => {\\r\\n  if (event.request.destination === \'image\') {\\r\\n    event.respondWith(\\r\\n      caches.open(\'images-v1\').then(cache => {\\r\\n        return cache.match(event.request).then(response => {\\r\\n          return response || fetch(event.request).then(fetchResponse => {\\r\\n            cache.put(event.request, fetchResponse.clone())\\r\\n            return fetchResponse\\r\\n          })\\r\\n        })\\r\\n      })\\r\\n    )\\r\\n  }\\r\\n})\\r\\n```\\r\\n\\r\\n### HTTP 缓存头\\r\\n\\r\\n```javascript\\r\\n// Next.js 缓存配置\\r\\nmodule.exports = {\\r\\n  async headers() {\\r\\n    return [\\r\\n      {\\r\\n        source: \'/images/:path*\',\\r\\n        headers: [\\r\\n          {\\r\\n            key: \'Cache-Control\',\\r\\n            value: \'public, max-age=31536000, immutable\'\\r\\n          }\\r\\n        ]\\r\\n      }\\r\\n    ]\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n## JavaScript 优化\\r\\n\\r\\n### Tree Shaking\\r\\n\\r\\n```javascript\\r\\n// 只导入需要的功能\\r\\nimport { debounce } from \'lodash-es\'\\r\\n// 而不是\\r\\nimport _ from \'lodash\'\\r\\n\\r\\n// 使用 babel-plugin-import 自动优化\\r\\nimport { Button, DatePicker } from \'antd\'\\r\\n```\\r\\n\\r\\n### 避免不必要的重新渲染\\r\\n\\r\\n```jsx\\r\\nimport { memo, useMemo, useCallback } from \'react\'\\r\\n\\r\\nconst ExpensiveComponent = memo(({ items, onItemClick }) => {\\r\\n  const processedItems = useMemo(() => {\\r\\n    return items.map(item => ({\\r\\n      ...item,\\r\\n      processed: true\\r\\n    }))\\r\\n  }, [items])\\r\\n\\r\\n  const handleClick = useCallback((id) => {\\r\\n    onItemClick(id)\\r\\n  }, [onItemClick])\\r\\n\\r\\n  return (\\r\\n    <div>\\r\\n      {processedItems.map(item => (\\r\\n        <Item \\r\\n          key={item.id} \\r\\n          item={item} \\r\\n          onClick={handleClick}\\r\\n        />\\r\\n      ))}\\r\\n    </div>\\r\\n  )\\r\\n})\\r\\n```\\r\\n\\r\\n## 网络优化\\r\\n\\r\\n### HTTP/2 推送\\r\\n\\r\\n```javascript\\r\\n// 服务器推送关键资源\\r\\napp.get(\'/\', (req, res) => {\\r\\n  res.push(\'/styles/critical.css\')\\r\\n  res.push(\'/scripts/main.js\')\\r\\n  res.render(\'index\')\\r\\n})\\r\\n```\\r\\n\\r\\n### 资源压缩\\r\\n\\r\\n```javascript\\r\\n// gzip/brotli 压缩\\r\\nconst compression = require(\'compression\')\\r\\napp.use(compression({\\r\\n  filter: (req, res) => {\\r\\n    if (req.headers[\'x-no-compression\']) {\\r\\n      return false\\r\\n    }\\r\\n    return compression.filter(req, res)\\r\\n  },\\r\\n  level: 6,\\r\\n  threshold: 1024\\r\\n}))\\r\\n```\\r\\n\\r\\n## 性能监控\\r\\n\\r\\n### 性能 API\\r\\n\\r\\n```javascript\\r\\n// 测量自定义指标\\r\\nperformance.mark(\'component-start\')\\r\\n// ... 组件渲染逻辑\\r\\nperformance.mark(\'component-end\')\\r\\nperformance.measure(\'component-render\', \'component-start\', \'component-end\')\\r\\n\\r\\n// 获取测量结果\\r\\nconst measures = performance.getEntriesByType(\'measure\')\\r\\nconsole.log(measures)\\r\\n```\\r\\n\\r\\n### Web Vitals 监控\\r\\n\\r\\n```javascript\\r\\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from \'web-vitals\'\\r\\n\\r\\nfunction sendToAnalytics(metric) {\\r\\n  // 发送到分析服务\\r\\n  analytics.track(\'web-vital\', {\\r\\n    name: metric.name,\\r\\n    value: metric.value,\\r\\n    id: metric.id\\r\\n  })\\r\\n}\\r\\n\\r\\ngetCLS(sendToAnalytics)\\r\\ngetFID(sendToAnalytics)\\r\\ngetFCP(sendToAnalytics)\\r\\ngetLCP(sendToAnalytics)\\r\\ngetTTFB(sendToAnalytics)\\r\\n```\\r\\n\\r\\n## 构建优化\\r\\n\\r\\n### Webpack 配置\\r\\n\\r\\n```javascript\\r\\nmodule.exports = {\\r\\n  optimization: {\\r\\n    splitChunks: {\\r\\n      chunks: \'all\',\\r\\n      cacheGroups: {\\r\\n        vendor: {\\r\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\r\\n          name: \'vendors\',\\r\\n          chunks: \'all\'\\r\\n        },\\r\\n        common: {\\r\\n          name: \'common\',\\r\\n          minChunks: 2,\\r\\n          chunks: \'all\',\\r\\n          enforce: true\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### 分析工具\\r\\n\\r\\n```bash\\r\\n# Bundle 分析\\r\\nnpm install --save-dev webpack-bundle-analyzer\\r\\nnpx webpack-bundle-analyzer build/static/js/*.js\\r\\n\\r\\n# 源码映射分析\\r\\nnpm install --save-dev source-map-explorer\\r\\nnpx source-map-explorer \'build/static/js/*.js\'\\r\\n```\\r\\n\\r\\n## 总结\\r\\n\\r\\n性能优化需要**持续关注**和**量化分析**：\\r\\n\\r\\n### 关键策略\\r\\n1. **测量优先**: 先测量，再优化\\r\\n2. **渐进增强**: 核心功能优先\\r\\n3. **用户体验**: 感知性能同样重要\\r\\n4. **持续监控**: 性能是一个持续过程\\r\\n\\r\\n### 工具推荐\\r\\n- **Lighthouse**: 综合分析\\r\\n- **WebPageTest**: 详细测试\\r\\n- **Chrome DevTools**: 开发调试\\r\\n- **Real User Monitoring**: 生产监控\\r\\n\\r\\n记住：**过早优化是万恶之源**，但合理的性能优化能显著提升用户体验。","author":"Jacky Feng","publishedAt":"2024-01-05","tags":["性能优化","Web Vitals","前端开发","用户体验"],"readingTime":15,"isPublished":true}]')}}]);