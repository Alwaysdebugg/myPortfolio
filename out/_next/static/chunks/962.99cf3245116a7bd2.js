"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[305,962],{1305:(n,e,t)=>{t.d(e,{fallbackBlogPosts:()=>s});let s=[{id:"react-18-new-features",title:"React 18 新特性深度解析",slug:"react-18-new-features",excerpt:"深入探讨 React 18 带来的并发特性、自动批处理、以及新的 Hooks，了解如何在项目中应用这些新特性。",content:"# React 18 新特性深度解析\n\nReact 18 是一个重要的版本更新，引入了许多令人兴奋的新特性。\n\n## 并发特性 (Concurrent Features)\n\nReact 18 的最大亮点是**并发渲染**，这使得 React 应用能够更好地响应用户交互。\n\n### Suspense 改进\n\n```jsx\nimport { Suspense } from 'react'\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <ProfilePage />\n    </Suspense>\n  )\n}\n```\n\n### 新的 Hooks\n\nReact 18 引入了几个新的 Hooks：\n\n- **useId**: 生成唯一ID\n- **useTransition**: 标记非紧急更新\n- **useDeferredValue**: 延迟更新值\n\n## 自动批处理\n\nReact 18 现在会自动批处理所有更新，包括Promise、setTimeout 等异步操作中的更新。\n\n```jsx\n// React 18 会自动批处理这些更新\nsetTimeout(() => {\n  setCount(c => c + 1)\n  setFlag(f => !f)\n  // React 只会重新渲染一次\n}, 1000)\n```\n\n## useTransition Hook\n\n`useTransition` 允许你将状态更新标记为\"转换\"，这些更新将具有较低的优先级。\n\n```jsx\nimport { useTransition, useState } from 'react'\n\nfunction App() {\n  const [isPending, startTransition] = useTransition()\n  const [count, setCount] = useState(0)\n  \n  function handleClick() {\n    startTransition(() => {\n      setCount(c => c + 1)\n    })\n  }\n  \n  return (\n    <div>\n      {isPending && <Spinner />}\n      <button onClick={handleClick}>{count}</button>\n    </div>\n  )\n}\n```\n\n## 严格模式的变化\n\nReact 18 的严格模式现在会**双重渲染组件**，这有助于发现副作用问题。\n\n> 在开发模式下，React 会故意双重调用组件、初始化函数和状态更新函数。\n\n## 总结\n\nReact 18 为现代 React 应用开发带来了更强大的性能优化能力。这些新特性让我们能够构建更加流畅和响应式的用户界面。\n\n### 关键要点\n\n1. **并发特性**提升了应用的响应性\n2. **自动批处理**减少了不必要的重新渲染\n3. **新的 Hooks** 提供了更精细的控制能力\n4. **严格模式**帮助开发者发现潜在问题",author:"Jacky Feng",publishedAt:"2024-01-15",updatedAt:"2024-01-20",tags:["React","JavaScript","前端开发","Hooks"],readingTime:8,coverImage:"/images/react18-cover.jpg",isPublished:!0},{id:"typescript-advanced-types",title:"TypeScript 高级类型实战指南",slug:"typescript-advanced-types",excerpt:"掌握 TypeScript 的高级类型系统，包括条件类型、映射类型、模板字面量类型等，提升代码质量和开发效率。",content:'# TypeScript 高级类型实战指南\n\nTypeScript 的类型系统非常强大，本文将深入探讨一些高级类型特性。\n\n## 条件类型 (Conditional Types)\n\n条件类型允许我们根据条件选择类型：\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T\n\n// 使用示例\ntype A = NonNullable<string | null> // string\ntype B = NonNullable<number | undefined> // number\n```\n\n### 分布式条件类型\n\n当条件类型作用于联合类型时，会分布到每个成员：\n\n```typescript\ntype ToArray<Type> = Type extends any ? Type[] : never\n\n// SuccessState | ErrorState[] | LoadingState[]\ntype StrArrOrNumArr = ToArray<string | number | boolean>\n```\n\n## 映射类型 (Mapped Types)\n\n映射类型可以基于已有类型创建新类型：\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype Optional<T> = {\n  [P in keyof T]?: T[P]\n}\n\n// 实际应用\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype ReadonlyUser = Readonly<User>\ntype PartialUser = Optional<User>\n```\n\n### 键重映射\n\nTypeScript 4.1+ 支持键重映射：\n\n```typescript\ntype Getters<Type> = {\n  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n}\n\ninterface Person {\n  name: string\n  age: number\n  location: string\n}\n\ntype PersonGetters = Getters<Person>\n// {\n//   getName: () => string\n//   getAge: () => number\n//   getLocation: () => string\n// }\n```\n\n## 模板字面量类型\n\nTypeScript 4.1+ 支持模板字面量类型：\n\n```typescript\ntype EmailLocaleIDs = "welcome_email" | "email_heading"\ntype FooterLocaleIDs = "footer_title" | "footer_sendoff"\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`\n// "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"\n```\n\n### 实际应用案例\n\n```typescript\n// API 路径类型安全\ntype Version = "v1" | "v2"\ntype Resource = "users" | "posts" | "comments"\ntype Endpoint = `/${Version}/${Resource}`\n\n// CSS 属性类型\ntype Size = "sm" | "md" | "lg"\ntype Color = "red" | "blue" | "green"\ntype ClassName = `${Size}-${Color}`\n```\n\n## 实用类型组合\n\n结合多种高级类型创建强大的工具类型：\n\n```typescript\n// 深度只读\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\n}\n\n// 选择性必需\ntype RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>\n\n// 类型安全的对象路径\ntype PathsToStringProps<T> = T extends string\n  ? []\n  : {\n      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>]\n    }[Extract<keyof T, string>]\n```\n\n## 最佳实践\n\n### 1. 类型守卫\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === \'string\'\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript 知道这里 value 是 string\n    console.log(value.toUpperCase())\n  }\n}\n```\n\n### 2. 断言函数\n\n```typescript\nfunction assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg)\n  }\n}\n\nfunction processUser(user: unknown) {\n  assert(typeof user === \'object\' && user !== null, \'User must be an object\')\n  assert(\'name\' in user, \'User must have a name\')\n  \n  // TypeScript 现在知道 user 有 name 属性\n  console.log((user as any).name)\n}\n```\n\n## 总结\n\n这些高级类型特性让我们能够构建更加类型安全的应用程序：\n\n- **条件类型**提供了动态类型选择能力\n- **映射类型**让类型转换变得优雅\n- **模板字面量类型**带来了字符串级别的类型安全\n- **合理组合**这些特性可以创建强大的工具类型\n\n掌握这些高级特性，能够大大提升 TypeScript 代码的表达力和安全性。',author:"Jacky Feng",publishedAt:"2024-01-10",tags:["TypeScript","类型系统","前端开发"],readingTime:12,isPublished:!0},{id:"frontend-performance-optimization",title:"现代前端性能优化实践",slug:"frontend-performance-optimization",excerpt:"从代码分割、懒加载到Web Vitals优化，全面提升前端应用性能的最佳实践和工具推荐。",content:"# 现代前端性能优化实践\n\n性能优化是前端开发中的重要课题，本文将介绍一些实用的优化策略。\n\n## Core Web Vitals\n\nGoogle 的 Core Web Vitals 包含三个重要指标：\n\n- **LCP (Largest Contentful Paint)**: 最大内容绘制 - 应 < 2.5s\n- **FID (First Input Delay)**: 首次输入延迟 - 应 < 100ms\n- **CLS (Cumulative Layout Shift)**: 累积布局偏移 - 应 < 0.1\n\n### 测量工具\n\n- **Lighthouse**: 综合性能分析\n- **PageSpeed Insights**: Google 官方工具\n- **Web Vitals Extension**: Chrome 扩展\n- **Real User Monitoring (RUM)**: 真实用户数据\n\n## 代码分割策略\n\n### 路由级别分割\n\n```javascript\nimport { lazy, Suspense } from 'react'\n\nconst HomePage = lazy(() => import('./pages/Home'))\nconst AboutPage = lazy(() => import('./pages/About'))\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Routes>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"/about\" element={<AboutPage />} />\n      </Routes>\n    </Suspense>\n  )\n}\n```\n\n### 组件级别分割\n\n对于大型组件，也可以进行分割：\n\n```javascript\nconst HeavyChart = lazy(() => import('./HeavyChart'))\n\nfunction Dashboard() {\n  const [showChart, setShowChart] = useState(false)\n  \n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>\n        显示图表\n      </button>\n      {showChart && (\n        <Suspense fallback={<ChartSkeleton />}>\n          <HeavyChart />\n        </Suspense>\n      )}\n    </div>\n  )\n}\n```\n\n### 第三方库分割\n\n```javascript\n// 动态导入第三方库\nconst loadChartLibrary = async () => {\n  const { Chart } = await import('chart.js')\n  return Chart\n}\n\n// 或者创建独立的 chunk\nconst DatePicker = lazy(() => \n  import(/* webpackChunkName: \"date-picker\" */ './DatePicker')\n)\n```\n\n## 图片优化\n\n### 现代图片格式\n\n```html\n<picture>\n  <source srcset=\"image.avif\" type=\"image/avif\">\n  <source srcset=\"image.webp\" type=\"image/webp\">\n  <img src=\"image.jpg\" alt=\"description\" loading=\"lazy\">\n</picture>\n```\n\n### 响应式图片\n\n```html\n<img \n  srcset=\"\n    small.jpg 480w,\n    medium.jpg 768w,\n    large.jpg 1200w\n  \"\n  sizes=\"\n    (max-width: 480px) 100vw,\n    (max-width: 768px) 50vw,\n    33vw\n  \"\n  src=\"medium.jpg\"\n  alt=\"Responsive image\"\n  loading=\"lazy\"\n>\n```\n\n### Next.js Image 组件\n\n```jsx\nimport Image from 'next/image'\n\nfunction OptimizedImage() {\n  return (\n    <Image\n      src=\"/hero-image.jpg\"\n      alt=\"Hero\"\n      width={800}\n      height={600}\n      priority // 对于 LCP 图片\n      placeholder=\"blur\"\n      blurDataURL=\"data:image/jpeg;base64,...\"\n    />\n  )\n}\n```\n\n## 资源预加载策略\n\n### 关键资源预加载\n\n```html\n\x3c!-- 预加载关键字体 --\x3e\n<link rel=\"preload\" href=\"/fonts/main.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n\n\x3c!-- 预加载关键 CSS --\x3e\n<link rel=\"preload\" href=\"/styles/critical.css\" as=\"style\">\n\n\x3c!-- 预连接到第三方域名 --\x3e\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"dns-prefetch\" href=\"//example.com\">\n```\n\n### 路由预加载\n\n```javascript\n// React Router 路由预加载\nimport { Link } from 'react-router-dom'\n\nfunction Navigation() {\n  return (\n    <Link \n      to=\"/dashboard\"\n      onMouseEnter={() => {\n        // 鼠标悬停时预加载\n        import('./pages/Dashboard')\n      }}\n    >\n      Dashboard\n    </Link>\n  )\n}\n```\n\n## 缓存策略\n\n### 浏览器缓存\n\n```javascript\n// Service Worker 缓存策略\nself.addEventListener('fetch', (event) => {\n  if (event.request.destination === 'image') {\n    event.respondWith(\n      caches.open('images-v1').then(cache => {\n        return cache.match(event.request).then(response => {\n          return response || fetch(event.request).then(fetchResponse => {\n            cache.put(event.request, fetchResponse.clone())\n            return fetchResponse\n          })\n        })\n      })\n    )\n  }\n})\n```\n\n### HTTP 缓存头\n\n```javascript\n// Next.js 缓存配置\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/images/:path*',\n        headers: [\n          {\n            key: 'Cache-Control',\n            value: 'public, max-age=31536000, immutable'\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n## JavaScript 优化\n\n### Tree Shaking\n\n```javascript\n// 只导入需要的功能\nimport { debounce } from 'lodash-es'\n// 而不是\nimport _ from 'lodash'\n\n// 使用 babel-plugin-import 自动优化\nimport { Button, DatePicker } from 'antd'\n```\n\n### 避免不必要的重新渲染\n\n```jsx\nimport { memo, useMemo, useCallback } from 'react'\n\nconst ExpensiveComponent = memo(({ items, onItemClick }) => {\n  const processedItems = useMemo(() => {\n    return items.map(item => ({\n      ...item,\n      processed: true\n    }))\n  }, [items])\n\n  const handleClick = useCallback((id) => {\n    onItemClick(id)\n  }, [onItemClick])\n\n  return (\n    <div>\n      {processedItems.map(item => (\n        <Item \n          key={item.id} \n          item={item} \n          onClick={handleClick}\n        />\n      ))}\n    </div>\n  )\n})\n```\n\n## 网络优化\n\n### HTTP/2 推送\n\n```javascript\n// 服务器推送关键资源\napp.get('/', (req, res) => {\n  res.push('/styles/critical.css')\n  res.push('/scripts/main.js')\n  res.render('index')\n})\n```\n\n### 资源压缩\n\n```javascript\n// gzip/brotli 压缩\nconst compression = require('compression')\napp.use(compression({\n  filter: (req, res) => {\n    if (req.headers['x-no-compression']) {\n      return false\n    }\n    return compression.filter(req, res)\n  },\n  level: 6,\n  threshold: 1024\n}))\n```\n\n## 性能监控\n\n### 性能 API\n\n```javascript\n// 测量自定义指标\nperformance.mark('component-start')\n// ... 组件渲染逻辑\nperformance.mark('component-end')\nperformance.measure('component-render', 'component-start', 'component-end')\n\n// 获取测量结果\nconst measures = performance.getEntriesByType('measure')\nconsole.log(measures)\n```\n\n### Web Vitals 监控\n\n```javascript\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'\n\nfunction sendToAnalytics(metric) {\n  // 发送到分析服务\n  analytics.track('web-vital', {\n    name: metric.name,\n    value: metric.value,\n    id: metric.id\n  })\n}\n\ngetCLS(sendToAnalytics)\ngetFID(sendToAnalytics)\ngetFCP(sendToAnalytics)\ngetLCP(sendToAnalytics)\ngetTTFB(sendToAnalytics)\n```\n\n## 构建优化\n\n### Webpack 配置\n\n```javascript\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all'\n        },\n        common: {\n          name: 'common',\n          minChunks: 2,\n          chunks: 'all',\n          enforce: true\n        }\n      }\n    }\n  }\n}\n```\n\n### 分析工具\n\n```bash\n# Bundle 分析\nnpm install --save-dev webpack-bundle-analyzer\nnpx webpack-bundle-analyzer build/static/js/*.js\n\n# 源码映射分析\nnpm install --save-dev source-map-explorer\nnpx source-map-explorer 'build/static/js/*.js'\n```\n\n## 总结\n\n性能优化需要**持续关注**和**量化分析**：\n\n### 关键策略\n1. **测量优先**: 先测量，再优化\n2. **渐进增强**: 核心功能优先\n3. **用户体验**: 感知性能同样重要\n4. **持续监控**: 性能是一个持续过程\n\n### 工具推荐\n- **Lighthouse**: 综合分析\n- **WebPageTest**: 详细测试\n- **Chrome DevTools**: 开发调试\n- **Real User Monitoring**: 生产监控\n\n记住：**过早优化是万恶之源**，但合理的性能优化能显著提升用户体验。",author:"Jacky Feng",publishedAt:"2024-01-05",tags:["性能优化","Web Vitals","前端开发","用户体验"],readingTime:15,isPublished:!0}]},7962:(n,e,t)=>{t.d(e,{getPublishedBlogPosts:()=>a});var s=t(1305);async function r(){try{let{default:n}=await t.e(348).then(t.t.bind(t,6348,19));if(n&&n.length>0)return console.log("Using generated blog posts from Markdown files"),n}catch(n){console.warn("Failed to load generated blog posts, falling back to static data:",n)}return console.log("Using fallback blog posts for static export"),s.fallbackBlogPosts}async function a(){return(await r()).filter(n=>n.isPublished)}}}]);